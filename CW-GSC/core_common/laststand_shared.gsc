/***********************************************
 * Decompiled by Ate47 and Edited by SyndiShanX
 * Script: core_common\laststand_shared.gsc
***********************************************/

#using scripts\autogenerated\luielems\core\revive_hud;
#using scripts\core_common\util_shared;
#namespace laststand;

function player_is_in_laststand() {
  return is_true(self.laststand);
}

function player_num_in_laststand() {
  num = 0;
  players = getplayers();

  for(i = 0; i < players.size; i++) {
    if(players[i] player_is_in_laststand()) {
      num++;
    }
  }

  return num;
}

function player_all_players_in_laststand() {
  return player_num_in_laststand() == getplayers().size;
}

function player_any_player_in_laststand() {
  return player_num_in_laststand() > 0;
}

function function_7fb2bbfc() {
  var_5eb47b1d = [];

  foreach(player in function_a1ef346b()) {
    if(!player inlaststand()) {
      if(!isDefined(var_5eb47b1d)) {
        var_5eb47b1d = [];
      } else if(!isarray(var_5eb47b1d)) {
        var_5eb47b1d = array(var_5eb47b1d);
      }

      var_5eb47b1d[var_5eb47b1d.size] = player;
    }
  }

  return var_5eb47b1d;
}

function is_facing(facee, requireddot = 0.9) {
  orientation = self getplayerangles();
  forwardvec = anglesToForward(orientation);
  forwardvec2d = (forwardvec[0], forwardvec[1], 0);
  unitforwardvec2d = vectornormalize(forwardvec2d);
  tofaceevec = facee.origin - self.origin;
  tofaceevec2d = (tofaceevec[0], tofaceevec[1], 0);
  unittofaceevec2d = vectornormalize(tofaceevec2d);
  dotproduct = vectordot(unitforwardvec2d, unittofaceevec2d);
  return dotproduct > requireddot;
}

function revive_hud_create() {
  assert(isDefined(level.revive_hud));

  if(!level.revive_hud revive_hud::is_open(self)) {
    level.revive_hud revive_hud::open(self, 1 | 2 | 4);
  }

  self thread function_7c7d873();
}

function function_7c7d873() {
  waitframe(1);
  self function_f5714974();
}

function revive_hud_show_n_fade(text, time, player = undefined) {
  if(!is_true(level.var_dc60105c) && isDefined(level.revive_hud) && level.revive_hud revive_hud::is_open(self)) {
    level.revive_hud revive_hud::set_fadetime(self, 0);
    util::wait_network_frame();

    if(!isDefined(self)) {
      return;
    }

    level.revive_hud revive_hud::set_text(self, text);

    if(isDefined(player)) {
      level.revive_hud revive_hud::set_clientnum(self, player getentitynumber());
    }

    level.revive_hud revive_hud::set_fadetime(self, int(time * 10));
  }
}

function function_f5714974() {
  if(isDefined(self) && isDefined(level.revive_hud) && level.revive_hud revive_hud::is_open(self)) {
    level.revive_hud revive_hud::set_fadetime(self, 0);
  }
}

function drawcylinder(pos, rad, height) {
  currad = rad;
  curheight = height;

  for(r = 0; r < 20; r++) {
    theta = r / 20 * 360;
    theta2 = (r + 1) / 20 * 360;
    line(pos + (cos(theta) * currad, sin(theta) * currad, 0), pos + (cos(theta2) * currad, sin(theta2) * currad, 0));
    line(pos + (cos(theta) * currad, sin(theta) * currad, curheight), pos + (cos(theta2) * currad, sin(theta2) * currad, curheight));
    line(pos + (cos(theta) * currad, sin(theta) * currad, 0), pos + (cos(theta) * currad, sin(theta) * currad, curheight));
  }
}

function function_d4c9e1b5() {
  self endon(#"player_revived", #"player_suicide", #"bled_out");
  self waittill(#"disconnect");

  if(isDefined(self.revivetrigger)) {
    self.revivetrigger delete();
  }
}